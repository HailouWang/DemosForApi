package com.example.radix;

/**
 * Created by ifei on 2017/8/3.
 */

public class Integer最高阶零位数的数目 {


    /**
     * Int整型数字，在Java中占用四个字节，共计32位。给定一个合法整型数字，
     * 构造一个函数，计算其最高阶之前的零位数。
     * 例如：2 ，16进制表示为：0x02，共含有30个零位数。
     *
     * 分析：
     *
     * 首先0，应该单独处理，因为正0和负0，结果不同。
     * 所有的负数，因为高位是1，其零位数都为0.
     * 正数的零位数至少为1.
     * 1001 和 1000，第四位都为1，那么，结果是一样的，都是前面28个零位数。
     *
     * 解题思路：
     * 1、单独处理0.因为0比较特殊。
     * 2、从高位向低位统计不为0的位处于第几位。
     * 那么，采用折半无符号右移，高位补0，判定是否为0，即可统计零位数。
     * 3、折半计算。先取32位的一半，即：16位。将数字i向右移动16位，
     * 如果为0，说明高16位全是零位数。【统计零位数，需要缩小无符号右移】
     * 如果不为0，说明高16位，存在数字，不是零位数。【不统计零位数，并继续扩大无符号右移位数】
     * 4、再次折半。扩大或者缩小范围
     *
     * 备注：第3步，我们每次计算完毕，情况不同，相应的需要扩大或者缩小 无符号右移位数，
     * 为了减少这个判定，可充分利用以下两个条件，将高位统计的零位数，相应的添加到末尾，也就是左移。
     * 这样子，每次都只需要统计高位的区域就可以了。
     * 1、无符号右移，高位补0.
     * 2、左移，低位补0.
     * @param i
     * @return
     */
    public static int numberOfLeadingZeros(int i) {
        // HD, Figure 5-6
        if (i == 0)
            return 32;
        int n = 1;
        if (i >>> 16 == 0) { n += 16; i <<= 16; }
        if (i >>> 24 == 0) { n +=  8; i <<=  8; }
        if (i >>> 28 == 0) { n +=  4; i <<=  4; }
        if (i >>> 30 == 0) { n +=  2; i <<=  2; }
        n -= i >>> 31;
        return n;
    }

}
